<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Conditional Probability Dice - Gabriella Chronis</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<style>
			.bigram-config {
				margin: 2em 0;
			}
			.word-section {
				margin: 1.5em 0;
				padding: 1em;
				background: rgba(255, 255, 255, 0.03);
				border-radius: 4px;
				border-left: 3px solid #18bfef;
			}
			.word-header {
				display: flex;
				align-items: center;
				gap: 1em;
				margin-bottom: 1em;
			}
			.word-input {
				flex: 1;
				max-width: 200px;
			}
			.bigram-input {
				display: flex;
				align-items: center;
				margin: 0.5em 0;
				gap: 1em;
				padding-left: 1em;
			}
			.bigram-input input[type="text"] {
				flex: 1;
				max-width: 150px;
			}
			.bigram-input input[type="number"] {
				max-width: 100px;
			}
			.controls {
				margin: 2em 0;
				display: flex;
				gap: 1em;
				flex-wrap: wrap;
				align-items: center;
			}
			.results {
				margin: 2em 0;
				padding: 1em;
				background: rgba(255, 255, 255, 0.05);
				border-radius: 4px;
			}
			.dice-container {
				display: flex;
				justify-content: center;
				align-items: center;
				margin: 2em 0;
				min-height: 120px;
				gap: 2em;
			}
			.dice {
				width: 100px;
				height: 100px;
				border: 3px solid #18bfef;
				border-radius: 15px;
				background: #fff;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.2em;
				font-weight: bold;
				color: #333;
				position: relative;
				transform-style: preserve-3d;
				transition: all 0.3s ease;
				box-shadow: 0 4px 8px rgba(0,0,0,0.2);
			}
			.dice.rolling {
				animation: rollDice 0.8s ease-in-out;
			}
			@keyframes rollDice {
				0% { transform: rotateX(0deg) rotateY(0deg); }
				25% { transform: rotateX(90deg) rotateY(45deg) scale(1.1); }
				50% { transform: rotateX(180deg) rotateY(90deg) scale(1.2); }
				75% { transform: rotateX(270deg) rotateY(135deg) scale(1.1); }
				100% { transform: rotateX(360deg) rotateY(180deg) scale(1); }
			}
			.dice-face {
				word-wrap: break-word;
				text-align: center;
				max-width: 90px;
				line-height: 1.2;
				padding: 5px;
			}
			.dice-label {
				text-align: center;
				margin-top: 0.5em;
				font-size: 0.9em;
				color: #18bfef;
			}
			.conditional-result {
				font-size: 1.3em;
				color: #18bfef;
				margin: 1em 0;
				text-align: center;
			}
			.error {
				color: #ff6b6b;
				margin: 1em 0;
			}
			.probability-sum {
				font-size: 0.8em;
				color: #888;
				margin-left: 1em;
			}
			.add-bigram {
				margin-left: 1em;
			}
			.current-context {
				background: rgba(24, 191, 239, 0.1);
				border: 1px solid #18bfef;
				border-radius: 4px;
				padding: 0.5em 1em;
				margin: 1em 0;
				text-align: center;
			}
			.model-container {
				margin: 2em 0;
				padding: 1em;
				background: rgba(255, 255, 255, 0.05);
				border-radius: 4px;
				min-height: 400px;
				overflow: auto;
			}
			#model-svg {
				width: 100%;
				height: 400px;
				border: 1px solid #333;
				border-radius: 4px;
				background: #fff;
			}
			.model-node {
				fill: #18bfef;
				stroke: #0d47a1;
				stroke-width: 2;
			}
			.model-node-text {
				fill: #fff;
				font-family: Arial, sans-serif;
				font-size: 12px;
				font-weight: bold;
				text-anchor: middle;
				dominant-baseline: middle;
			}
			.model-edge {
				stroke: #333;
				stroke-width: 2;
				fill: none;
				marker-end: url(#arrowhead);
			}
			.model-edge-label {
				fill: #333;
				font-family: Arial, sans-serif;
				font-size: 10px;
				text-anchor: middle;
				background: #fff;
			}
			.model-edge-bg {
				fill: #fff;
				stroke: #fff;
				stroke-width: 3;
			}
		</style>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="index.html">Home</a></li>
							<li><a href="publications.html">Publications</a></li>
							<li><a href="cv.html">CV</a></li>
							<li><a href="dice-roller.html">Simple Dice</a></li>
							<li class="active"><a href="conditional-dice.html">Conditional Dice</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<h1>Conditional Probability Dice</h1>
									<p>Simulate bigram language models: roll words based on what came before</p>
								</header>

								<div class="bigram-config">
									<h2>Configure Bigram Probabilities</h2>
									<p>The bigram model depends on conditional probability distribution for bigrams. We need to know, for each word type, given that we have already rolled that word, what is the probability that it will be followed by another word. Use the conditional frequency counts you derived to get the probabilities. You can enter the raw token counts. The normalize button will transform these counts into probabilities between 0 and 1.</p>
									<p>Set the probability of rolling each word given the previous word. For each starting word, the probabilities of following words should sum to 1.0.</p>
									
									<div id="bigram-container">
										<div class="word-section">
											<div class="word-header">
												<label>Word type:</label>
												<input type="text" class="word-input" placeholder="the" value="the">
												<span class="probability-sum">Sum: <span class="sum-value">0.00</span></span>
												<button class="normalize-word button small">Normalize</button>
											</div>
											<div class="bigrams-list">
												<div class="bigram-input">
													<label>Next word:</label>
													<input type="text" class="next-word" placeholder="cat" value="cat">
													<label>Probability:</label>
													<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.5">
													<button class="remove-bigram button small">Remove</button>
												</div>
												<div class="bigram-input">
													<label>Next word:</label>
													<input type="text" class="next-word" placeholder="dog" value="dog">
													<label>Probability:</label>
													<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.3">
													<button class="remove-bigram button small">Remove</button>
												</div>
												<div class="bigram-input">
													<label>Next word:</label>
													<input type="text" class="next-word" placeholder="fig" value="fig">
													<label>Probability:</label>
													<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.1">
													<button class="remove-bigram button small">Remove</button>
												</div>
											</div>
											<button class="add-bigram button small">Add Next Word</button>
										</div>
										
										<div class="word-section">
											<div class="word-header">
												<label>Word type:</label>
												<input type="text" class="word-input" placeholder="cat" value="cat">
												<span class="probability-sum">Sum: <span class="sum-value">0.00</span></span>
												<button class="normalize-word button small">Normalize</button>
											</div>
											<div class="bigrams-list">
												<div class="bigram-input">
													<label>Next word:</label>
													<input type="text" class="next-word" placeholder="gave" value="gave">
													<label>Probability:</label>
													<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.4">
													<button class="remove-bigram button small">Remove</button>
												</div>
											</div>
											<button class="add-bigram button small">Add Next Word</button>
										</div>

										<div class="word-section">
											<div class="word-header">
												<label>Word type:</label>
												<input type="text" class="word-input" placeholder="gave" value="gave">
												<span class="probability-sum">Sum: <span class="sum-value">0.00</span></span>
												<button class="normalize-word button small">Normalize</button>
											</div>
											<div class="bigrams-list">
												<div class="bigram-input">
													<label>Next word:</label>
													<input type="text" class="next-word" placeholder="the" value="the">
													<label>Probability:</label>
													<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.7">
													<button class="remove-bigram button small">Remove</button>
												</div>
											</div>
											<button class="add-bigram button small">Add Next Word</button>
										</div>
										
										<div class="word-section">
											<div class="word-header">
												<label>Word type:</label>
												<input type="text" class="word-input" placeholder="dog" value="dog">
												<span class="probability-sum">Sum: <span class="sum-value">0.00</span></span>
												<button class="normalize-word button small">Normalize</button>
											</div>
											<div class="bigrams-list">
												<div class="bigram-input">
													<label>Next word:</label>
													<input type="text" class="next-word" placeholder="the" value="the">
													<label>Probability:</label>
													<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.5">
													<button class="remove-bigram button small">Remove</button>
												</div>
											</div>
											<button class="add-bigram button small">Add Next Word</button>
										</div>
										
										<div class="word-section">
											<div class="word-header">
												<label>Word type:</label>
												<input type="text" class="word-input" placeholder="fig" value="fig">
												<span class="probability-sum">Sum: <span class="sum-value">0.00</span></span>
												<button class="normalize-word button small">Normalize</button>
											</div>
											<div class="bigrams-list">
												<div class="bigram-input">
													<label>Next word:</label>
													<input type="text" class="next-word" placeholder="." value=".">
													<label>Probability:</label>
													<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.6">
													<button class="remove-bigram button small">Remove</button>
												</div>
												<div class="bigram-input">
													<label>Next word:</label>
													<input type="text" class="next-word" placeholder="away" value="away">
													<label>Probability:</label>
													<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.4">
													<button class="remove-bigram button small">Remove</button>
												</div>
											</div>
											<button class="add-bigram button small">Add Next Word</button>
										</div>
										
										
									</div>
									
									<div class="controls">
										<button id="add-word" class="button">Add Word Type</button>
										<button id="normalize-all" class="button">Normalize All</button>
									</div>
								</div>

								<div class="controls">
									<h2>Build Markov Model</h2>
									<p>Generate a visual diagram of your bigram model showing states (words) and transitions (probabilities).</p>
									<button id="build-model" class="button primary">Build Model Diagram</button>
									<div class="model-container">
										<svg id="model-svg">
											<defs>
												<marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
													<polygon points="0 0, 10 3.5, 0 7" fill="#333" />
												</marker>
											</defs>
											<text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle" fill="#888" font-size="16">Click "Build Model Diagram" to visualize your bigram model</text>
										</svg>
									</div>
								</div>

								<div class="controls">
									<h2>Roll Conditional Dice</h2>
									<div class="current-context" id="current-context">
										<strong>Current context:</strong> <span id="context-word">[Start of sentence]</span>
									</div>
									<div class="dice-container">
										<div>
											<div id="prev-dice" class="dice" style="display: none;">
												<div class="dice-face">?</div>
											</div>
											<div class="dice-label">Previous</div>
										</div>
										<div>
											<div id="current-dice" class="dice" style="display: none;">
												<div class="dice-face">?</div>
											</div>
											<div class="dice-label">Current Roll</div>
										</div>
									</div>
									<button id="conditional-roll" class="button primary">Roll Next Word</button>
									<button id="reset-context" class="button small">Reset Context</button>
								</div>

								<div class="results" id="results" style="display: none;">
									<h3>Results</h3>
									<div id="result-content"></div>
								</div>

								<div class="controls">
									<h2>Generate Conditional String</h2>
									<div style="display: flex; gap: 1em; align-items: center; margin-bottom: 1em;">
										<label>Length:</label>
										<input type="number" id="string-length" min="1" max="50" value="10" style="width: 80px;">
										<button id="generate-string" class="button">Generate String</button>
										<button id="refresh-string" class="button small">Clear String</button>
									</div>
									<div id="generated-string" style="padding: 1em; background: rgba(255, 255, 255, 0.05); border-radius: 4px; min-height: 2em; font-family: monospace; word-wrap: break-word;"></div>
								</div>

							</section>

					</div>

				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; Gabriella Chronis</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script>
				$(document).ready(function() {
					let currentContext = null;
					let generatedString = '';

					// Update probability sum for a word section
					function updateProbabilitySum(wordSection) {
						const probs = wordSection.find('.bigram-prob');
						const total = probs.toArray().reduce((sum, el) => sum + (parseFloat($(el).val()) || 0), 0);
						wordSection.find('.sum-value').text(total.toFixed(2));
						wordSection.find('.sum-value').css('color', Math.abs(total - 1.0) < 0.01 ? '#4CAF50' : '#ff6b6b');
					}

					// Update all probability sums
					function updateAllSums() {
						$('.word-section').each(function() {
							updateProbabilitySum($(this));
						});
					}

					// Add bigram to existing word
					$(document).on('click', '.add-bigram', function() {
						const bigramsList = $(this).siblings('.bigrams-list');
						const newBigram = $(`
							<div class="bigram-input">
								<label>Next word:</label>
								<input type="text" class="next-word" placeholder="word">
								<label>Probability:</label>
								<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.00">
								<button class="remove-bigram button small">Remove</button>
							</div>
						`);
						bigramsList.append(newBigram);
						updateProbabilitySum($(this).parent());
					});

					// Remove bigram
					$(document).on('click', '.remove-bigram', function() {
						const wordSection = $(this).closest('.word-section');
						$(this).parent().remove();
						updateProbabilitySum(wordSection);
					});

					// Add new word section
					$('#add-word').click(function() {
						const wordCount = $('.word-section').length + 1;
						const newWordSection = $(`
							<div class="word-section">
								<div class="word-header">
									<label>Word type:</label>
									<input type="text" class="word-input" placeholder="word${wordCount}" value="word${wordCount}">
									<span class="probability-sum">Sum: <span class="sum-value">0.00</span></span>
									<button class="normalize-word button small">Normalize</button>
									<button class="remove-word button small">Remove Word</button>
								</div>
								<div class="bigrams-list">
									<div class="bigram-input">
										<label>Next word:</label>
										<input type="text" class="next-word" placeholder="word">
										<label>Probability:</label>
										<input type="number" class="bigram-prob" step="0.01" min="0" max="1" value="0.00">
										<button class="remove-bigram button small">Remove</button>
									</div>
								</div>
								<button class="add-bigram button small">Add Next Word</button>
							</div>
						`);
						$('#bigram-container').append(newWordSection);
						updateProbabilitySum(newWordSection);
					});

					// Remove word section
					$(document).on('click', '.remove-word', function() {
						$(this).closest('.word-section').remove();
					});

					// Normalize probabilities for one word
					$(document).on('click', '.normalize-word', function() {
						const wordSection = $(this).closest('.word-section');
						const probs = wordSection.find('.bigram-prob');
						const total = probs.toArray().reduce((sum, el) => sum + (parseFloat($(el).val()) || 0), 0);
						if (total > 0) {
							probs.each(function() {
								const currentVal = parseFloat($(this).val()) || 0;
								$(this).val((currentVal / total).toFixed(3));
							});
						}
						updateProbabilitySum(wordSection);
					});

					// Normalize all probabilities
					$('#normalize-all').click(function() {
						$('.normalize-word').click();
					});

					// Update sums when probabilities change
					$(document).on('input', '.bigram-prob', function() {
						updateProbabilitySum($(this).closest('.word-section'));
					});

					// Get bigram configuration
					function getBigramConfig() {
						const config = {};
						$('.word-section').each(function() {
							const word = $(this).find('.word-input').val().trim();
							if (!word) return;
							
							const bigrams = [];
							$(this).find('.bigram-input').each(function() {
								const nextWord = $(this).find('.next-word').val().trim();
								const prob = parseFloat($(this).find('.bigram-prob').val()) || 0;
								if (nextWord && prob > 0) {
									bigrams.push({ word: nextWord, prob });
								}
							});
							
							if (bigrams.length > 0) {
								config[word] = bigrams;
							}
						});
						return config;
					}

					// Validate bigram probabilities
					function validateBigrams(config) {
						for (let word in config) {
							const total = config[word].reduce((sum, bigram) => sum + bigram.prob, 0);
							if (Math.abs(total - 1.0) > 0.01) {
								return false;
							}
						}
						return true;
					}

					// Roll next word based on current context
					function rollConditionalDice(config, context) {
						if (!context || !config[context]) {
							// If no context or no bigrams for context, pick randomly from all possible words
							const allWords = Object.keys(config);
							if (allWords.length === 0) return null;
							return allWords[Math.floor(Math.random() * allWords.length)];
						}

						const bigrams = config[context];
						const random = Math.random();
						let cumulative = 0;
						
						for (let bigram of bigrams) {
							cumulative += bigram.prob;
							if (random <= cumulative) {
								return bigram.word;
							}
						}
						
						return bigrams[bigrams.length - 1].word; // Fallback
					}

					// Conditional roll
					$('#conditional-roll').click(function() {
						const config = getBigramConfig();
						if (Object.keys(config).length === 0) {
							showError('Please configure at least one word with bigram probabilities.');
							return;
						}

						// Show animations
						const prevDice = $('#prev-dice');
						const currentDice = $('#current-dice');
						
						if (currentContext) {
							prevDice.find('.dice-face').text(currentContext);
							prevDice.show();
						}
						
						currentDice.show();
						currentDice.addClass('rolling');
						$('#results').hide();

						// After animation
						setTimeout(function() {
							const result = rollConditionalDice(config, currentContext);
							currentDice.removeClass('rolling');
							
							if (result) {
								currentDice.find('.dice-face').text(result);
								showConditionalResult(currentContext, result);
								currentContext = result;
								$('#context-word').text(currentContext);
							} else {
								showError('No valid transitions available from current context.');
							}
						}, 800);
					});

					// Reset context
					$('#reset-context').click(function() {
						currentContext = null;
						$('#context-word').text('[Start of sentence]');
						$('#prev-dice').hide();
						$('#current-dice').hide();
						$('#results').hide();
					});

					// Generate string
					$('#generate-string').click(function() {
						const config = getBigramConfig();
						const length = parseInt($('#string-length').val()) || 10;
						
						if (Object.keys(config).length === 0) {
							showError('Please configure at least one word with bigram probabilities.');
							return;
						}

						let string = '';
						let context = null;
						
						for (let i = 0; i < length; i++) {
							const nextWord = rollConditionalDice(config, context);
							if (!nextWord) break;
							
							if (string.length > 0) {
								string += ' ' + nextWord;
							} else {
								string = nextWord;
							}
							context = nextWord;
						}
						
						$('#generated-string').text(string);
					});

					// Clear string
					$('#refresh-string').click(function() {
						$('#generated-string').text('');
					});

					// Show conditional result
					function showConditionalResult(prev, current) {
						let content = '<div class="conditional-result">';
						if (prev) {
							content += `After <strong>${prev}</strong>, rolled: <strong>${current}</strong>`;
						} else {
							content += `Started with: <strong>${current}</strong>`;
						}
						content += '</div>';
						
						$('#result-content').html(content);
						$('#results').show();
					}

					// Show error
					function showError(message) {
						const content = `<div class="error">${message}</div>`;
						$('#result-content').html(content);
						$('#results').show();
					}

					// Build Markov model diagram
					$('#build-model').click(function() {
						const config = getBigramConfig();
						if (Object.keys(config).length === 0) {
							showError('Please configure at least one word with bigram probabilities to build the model.');
							return;
						}
						buildMarkovModel(config);
					});

					// Build visual Markov model
					function buildMarkovModel(config) {
						const svg = document.getElementById('model-svg');
						const svgWidth = svg.clientWidth;
						const svgHeight = svg.clientHeight;
						
						// Clear existing content
						svg.innerHTML = `
							<defs>
								<marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
									<polygon points="0 0, 10 3.5, 0 7" fill="#333" />
								</marker>
							</defs>
						`;

						// Get all unique words (nodes)
						const words = Object.keys(config);
						const allTargets = new Set();
						Object.values(config).forEach(bigrams => {
							bigrams.forEach(bigram => allTargets.add(bigram.word));
						});
						const allWords = [...new Set([...words, ...allTargets])];

						// Calculate node positions in a circle
						const centerX = svgWidth / 2;
						const centerY = svgHeight / 2;
						const radius = Math.min(svgWidth, svgHeight) * 0.3;
						const nodeRadius = 25;
						const positions = {};

						allWords.forEach((word, index) => {
							const angle = (2 * Math.PI * index) / allWords.length;
							positions[word] = {
								x: centerX + radius * Math.cos(angle),
								y: centerY + radius * Math.sin(angle)
							};
						});

						// Detect bidirectional connections for curved arrows
						const bidirectional = new Set();
						Object.keys(config).forEach(fromWord => {
							config[fromWord].forEach(bigram => {
								if (config[bigram.word] && config[bigram.word].some(b => b.word === fromWord)) {
									// Both directions exist - mark for curved drawing
									const key1 = `${fromWord}-${bigram.word}`;
									const key2 = `${bigram.word}-${fromWord}`;
									bidirectional.add(key1);
									bidirectional.add(key2);
								}
							});
						});

						// Draw edges (transitions) first so they appear behind nodes
						Object.keys(config).forEach(fromWord => {
							const fromPos = positions[fromWord];
							config[fromWord].forEach(bigram => {
								const toPos = positions[bigram.word];
								if (fromPos && toPos && bigram.prob > 0) {
									const connectionKey = `${fromWord}-${bigram.word}`;
									const isBidirectional = bidirectional.has(connectionKey);
									drawEdge(svg, fromPos, toPos, bigram.prob, fromWord === bigram.word, isBidirectional, fromWord, bigram.word);
								}
							});
						});

						// Draw nodes (states)
						allWords.forEach(word => {
							const pos = positions[word];
							drawNode(svg, pos.x, pos.y, word, config[word] ? true : false);
						});
					}

					// Draw a node (state)
					function drawNode(svg, x, y, text, hasTransitions) {
						const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
						
						// Node circle
						const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
						circle.setAttribute('cx', x);
						circle.setAttribute('cy', y);
						circle.setAttribute('r', 25);
						circle.setAttribute('class', 'model-node');
						if (!hasTransitions) {
							circle.setAttribute('fill', '#999'); // Gray for terminal states
						}
						
						// Node text
						const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
						textElement.setAttribute('x', x);
						textElement.setAttribute('y', y);
						textElement.setAttribute('class', 'model-node-text');
						textElement.textContent = text.length > 8 ? text.substring(0, 6) + '...' : text;
						
						g.appendChild(circle);
						g.appendChild(textElement);
						svg.appendChild(g);
					}

					// Draw an edge (transition)
					function drawEdge(svg, fromPos, toPos, probability, isSelfLoop, isBidirectional, fromWord, toWord) {
						const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
						
						if (isSelfLoop) {
							// Draw self-loop as a circle above the node
							const loopRadius = 15;
							const loopCenterX = fromPos.x;
							const loopCenterY = fromPos.y - 40;
							
							const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
							const pathData = `M ${fromPos.x - 10} ${fromPos.y - 25} 
											Q ${loopCenterX - loopRadius} ${loopCenterY} ${loopCenterX} ${loopCenterY - loopRadius} 
											Q ${loopCenterX + loopRadius} ${loopCenterY} ${fromPos.x + 10} ${fromPos.y - 25}`;
							path.setAttribute('d', pathData);
							path.setAttribute('class', 'model-edge');
							
							// Label for self-loop
							const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
							labelBg.setAttribute('cx', loopCenterX);
							labelBg.setAttribute('cy', loopCenterY - loopRadius);
							labelBg.setAttribute('r', 12);
							labelBg.setAttribute('class', 'model-edge-bg');
							
							const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
							label.setAttribute('x', loopCenterX);
							label.setAttribute('y', loopCenterY - loopRadius);
							label.setAttribute('class', 'model-edge-label');
							label.textContent = probability.toFixed(2);
							
							g.appendChild(path);
							g.appendChild(labelBg);
							g.appendChild(label);
							
						} else if (isBidirectional) {
							// Use curved arrows for bidirectional connections
							const dx = toPos.x - fromPos.x;
							const dy = toPos.y - fromPos.y;
							const distance = Math.sqrt(dx * dx + dy * dy);
							const unitX = dx / distance;
							const unitY = dy / distance;
							
							// Start and end points on circle circumference
							const startX = fromPos.x + unitX * 25;
							const startY = fromPos.y + unitY * 25;
							const endX = toPos.x - unitX * 25;
							const endY = toPos.y - unitY * 25;
							
							// Calculate control point for curve
							// Use a consistent curve direction based on word comparison to avoid asymmetry
							const curveOffset = 30;
							const perpX = -unitY; // Perpendicular to the line
							const perpY = unitX;
							
							// Determine curve direction consistently
							const curveDirection = fromWord < toWord ? 1 : -1;
							const controlX = (startX + endX) / 2 + perpX * curveOffset * curveDirection;
							const controlY = (startY + endY) / 2 + perpY * curveOffset * curveDirection;
							
							// Create curved path
							const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
							const pathData = `M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}`;
							path.setAttribute('d', pathData);
							path.setAttribute('class', 'model-edge');
							
							// Position label at the curve's midpoint
							const t = 0.5; // Parameter for quadratic bezier curve
							const labelX = (1-t)*(1-t)*startX + 2*(1-t)*t*controlX + t*t*endX;
							const labelY = (1-t)*(1-t)*startY + 2*(1-t)*t*controlY + t*t*endY;
							
							const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
							labelBg.setAttribute('cx', labelX);
							labelBg.setAttribute('cy', labelY);
							labelBg.setAttribute('r', 10);
							labelBg.setAttribute('class', 'model-edge-bg');
							
							const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
							label.setAttribute('x', labelX);
							label.setAttribute('y', labelY);
							label.setAttribute('class', 'model-edge-label');
							label.textContent = probability.toFixed(2);
							
							g.appendChild(path);
							g.appendChild(labelBg);
							g.appendChild(label);
							
						} else {
							// Draw straight arrow for unidirectional connections
							const dx = toPos.x - fromPos.x;
							const dy = toPos.y - fromPos.y;
							const distance = Math.sqrt(dx * dx + dy * dy);
							const unitX = dx / distance;
							const unitY = dy / distance;
							
							const startX = fromPos.x + unitX * 25;
							const startY = fromPos.y + unitY * 25;
							const endX = toPos.x - unitX * 25;
							const endY = toPos.y - unitY * 25;
							
							// Edge line
							const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
							line.setAttribute('x1', startX);
							line.setAttribute('y1', startY);
							line.setAttribute('x2', endX);
							line.setAttribute('y2', endY);
							line.setAttribute('class', 'model-edge');
							
							// Label background
							const midX = (startX + endX) / 2;
							const midY = (startY + endY) / 2;
							
							const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
							labelBg.setAttribute('cx', midX);
							labelBg.setAttribute('cy', midY);
							labelBg.setAttribute('r', 10);
							labelBg.setAttribute('class', 'model-edge-bg');
							
							// Label text
							const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
							label.setAttribute('x', midX);
							label.setAttribute('y', midY);
							label.setAttribute('class', 'model-edge-label');
							label.textContent = probability.toFixed(2);
							
							g.appendChild(line);
							g.appendChild(labelBg);
							g.appendChild(label);
						}
						
						svg.appendChild(g);
					}

					// Initialize sums
					updateAllSums();
				});
			</script>

	</body>
</html>